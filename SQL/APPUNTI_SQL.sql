    /*APPUNTI SQL*/
    /*MANUALE IN CONTINUO AGGIORNAMENTO*/

    /*comando SELECT: usato per interrogazioni con sintassi*/
    SELECT DISTINCT [attributes] FROM (TABLE) WHERE (CONDIZIONE)

    /*attributi:  *= tutti gli attributi presenti nelle tabelle
                campo1, campo2 = seleziona solo i campi selezionati  
                tabella1, tabella2 = per relazionare due tabelle
    */
    /*EX*/ SELECT DISTINCT a1, a2, a3, ... FROM t1, t2, t3, ... WHERE c

    /*EX: VEDERE INDIRIZZO E NUMERO DI TELEFONO DELLO STUDENTE TEO VERDI*/
    SELECT indirizzo, telefono FROM studenti WHERE nome= 'TEO VERDI'

    /*I COMANDI DI SQL NON SONO CASE SENSITIVE
    POSSONON ESSERE DISTRIBUITE IN UNO O PIÚ RIGHE
    LE CHIAVI NON POSSONO ESSERE SPEZZETTATE DA UN RIGO E L'ALTRO
    */

    /*POSSIAMO CREARE OPERAZIONI TRAMITE OPERATORI ARITMETICI: +, -, *, /, ecc.*/

    /*RINOMINARE UN ATTRIBUTO QUANDO CI CONVIENE*/
    SELECT ename AS name, sal (AS) salary FROM emp
    /*POSSIAMO OMETTERE AS, PER PURISMO LO INSERIAMO*/

    /*POSSIAMO RINOMINARE ANCHE LE TABELLE*/
    SELECT professore FORM corsi (AS) p, esami (AS) e WHERE p.corso = e.corso AND matricola = "123456"
    /*professori con cui la matricola ha fatto esami*/

    /*ELIMINAZIONE DELLE RIGHE DUPLICATE*/
    SELECT DISTINCT deptno FROM emp
    /*RESTITUISCE TUTTE LE RIGHE HANNO depnot TUTTE DIVERSE*/

    /*LIMITARE LE RIGHE SELEZIONATE*/
    SELECT ename, job, deptno FROM emp WHERE sal<=comm
    /*confronto tra due attributi (sal e comm)*/

    /*OPERARTORI CONFRONTO OPERAZIONALI*/
    BETWEEN ... AND .... /*CONSENTE DI RESTITUIRE I RECORD SU UN INTERVALLO*/
    IN (list) /*SPECIFICARE UNA SERIE DI VALORI PER RESTITUIRE QUEL VALORE SPECIFICATO*/
    LIKE /*OPERATORE PATTERN MATCHING, ASSOMIGLIA A*/
    IS NULL /*VALORE NULLO*/

    /*EX*/ SELECT ename, sal FROM emp WHERE sal BETWEEN 1000 AND 1500
    /*restituisce tutti i record ename sal, con sal compreso tra 1000 e 1500*/

    /*EX*/ SELECT empno, ename, sal, mgr, FORM emp WHERE mgr IN (7902, 7566, 7788)
    /*seleziona i record con mgr uguale ai valori forniti*/

    /*EX*/ SELECT ename FROM emp WHERE ename LIKE 'S%'
    /*restituisce tutti i nomi che iniziano per S o solamente S*/
    /*ricerche wildcard:      %= denota zero o più caratteri; _=uno e un solo carattere*/
    /*S__ = stringa con iniziale S + due caratteri*/
    /*%S% = stringa con in mezzo S, non posizione esatta*/
    /*\% = cercami la stringa con %*, \= annulla il comando/

    /*EX*/ SELECT ename FROM emp WHERE sal IS (NOT) NULL
    /*SALARIO NULLO, NOT NULLO*/

    /*TUTTI STI ATTRIBUTI, CONDIZIONI, PREDICATI POSSONO ESSERE UNITI TRA DI LORO*/
    /*EX*/ SELECT ename, job, sal FROM emp WHERE job='salesman' OR job="president" AND sal>=1600

    /*ORDER BY: CONSENTE DI EFFETTUARE UN ORDINAMENTE A SECONDO DI UNO O PIÚ ATTRIBUTI*/
    /*EX*/ SELECT ename, job, deptno, hiredate FROM emp ORDER BY DESC (discendente) ASC (ascendente)
    /*EX*/ SELECT ename, job, deptno, hiredate, sal*12 (AS) annsal FROM emp ORDER BY annsal
    /*EX*/ SELECT ename, deptno FROM emp ORDER BY deptno, sal


    /*JOIN: VIENE USATA PER EFFETTUARE QUERY SU PIÚ TABELLE*/
    SELECT T1.C1, T2.C2 FROM T1, T2 WHERE T1.C1 = T2.C2 /*(T1.C1 = T2.C2) || (T1.C1 != T2.C2)*/
    /*EX*/SELECT Corso FROM Esami,Studenti WHERE Esami.Matricola = Studenti.Matricola AND Nome='Mario Rossi'
    /*EX*/SELECT madre, paternita.figlio, padre FROM maternita WHERE paternita.figlio = maternita.figlio
    
    /*NATURAL JOIN:*/
    SELECT T1.C1, T2.C2 FROM T2 WHERE NATURAL JOIN T1
    /*EX*/SELECT Studenti.Nome,Esami.Corso,Esami.Voto FROM Esami NATURAL JOIN Studenti

    /*JOIN ON: TRAMITE OPERATORE JOIN ON*/
    SELECT C1, T1.C2, C2 FROM T2 JOIN T1 ON T1.C2 = T2.C3  /*C2 = C3*/
    /*EX*/SELECT madre, paternita.figlio, padre FROM maternita JOIN paternita ON paternita.figlio = maternita.figlio
    
    /*LEFT JOIN*/
    SELECT T1.C1, C2, C3, FROM T1 LEFT JOIN T2 ON T1.C1 = T2.C1
    /*EX*/SELECT paternita.figlio, padre, madre FROM paternita LEFT JOIN maternita ON paternita.figlio = maternita.figlio    

    /*FULL JOIN*/
    SELECT T1.C1, C2, C3, FROM T1 FULL JOIN T2 ON T1.C1 = T2.C1
    /*EX*/SELECT paternita.figlio, padre, madre FROM paternita FULL JOIN maternita ON paternita.figlio = maternita.figlio 

    /*CROSS JOIN: PRODOTTO CARTESIANO TRA DUE TABELLE*/
    
    /*UNION JOIN ... ON: UNIONE ESTESA, SI ESTENDONO LE DUE 
    TABELLE CON LE COLONNE DELL'ALTRO CON VALORI NULLI E EFFETTUA L'UNIONE
    */

    /*UNION: OPERATORE UNIONE*/
    SELECT C1, C2 FROM T1 WHERE (*) UNION SELECT C3, C4 FROM T2 WHERE (*)
    /*EX*/SELECT padre FROM paternita UNION SELECT madre FROM maternita

    /*OPERATORI VARI*/
    AVG(*) /*MEDIA*/
    COUNT(*) /*CONTATORE ELEMENTI*/
    MAX(*) /*MASSIMO*/
    MIN(*) /*MINIMO*/
    SUM(*) /*SOMMA*/ 

    /*HAVING: FILTRO AGGIUNTIVO, AMMETTE COME ARGOMENTO UN'ESPRESSIONE BOOLEANA SU PREDICATI SEMPLICI*/
    HAVING (CONDIZIONE AGGIUNTIVA)
    /*EX*/SELECT Nome, Matricola, MIN(Voto), MAX(Voto),AVG(Voto) FROM Esami, Studenti WHERE Esami.Matricola = Studenti.Matricola 
          GROUP BY Nome,Matricola HAVING COUNT(*) > 8

    /*GROUP BY: RAGGRUPPAMENTO PER ATTRIBUTI*/
    GROUP BY (A1, A2) /*LISTA DI ATTRIBUTI DI RAGGRUPPAMENTO*/


    /*INTERROGAZIONI NIDIFICATE*/
    SELECT A1, A2.. FROM T1 WHERE A1 = (SUBQUERY)
    /*EX*/SELECT Nome, Reddito FROM Persone WHERE Nome = ( SELECT Padre FROM Paternita WHERE Figlio = 'Franco')

    /*CONFRONTI CON CONDIZIONI SQL FRA ATTRIBUTO E RISULTATO DELLA SUBQUERY*/
    A1 OP (ANY | ALL) (SUBQUERY)
    
    /*ANY/IN (SINONIMO): IL PREDICATO É VERO SE E SOLO SE UNO DEI RECORD RESTITUITI SODDISFANO LA CONDIZIONE*/
    /*ALL: IL PREDICATO É VERO SE E SOLO SE TUTTI I RECORD RESTITUITI SODDISFANO LA CONDIZIONE*/
    /*EX*/SELECT Nome, Reddito FROM Persone WHERE Nome IN 
          (SELECT Padre FROM Paternita WHERE Figlio = ANY (SELECT Nome FROM Persone WHERE Reddito > 20))


    /*QUANTIFICATORE ESISTENZIOALE:*/
    A1 [NOT] EXIST (SUBQUERY) /*IL PREDICATO É VERO SE E SOLO SE RESTITUSCE ALMENO UNA TUPLA*/

    /*NOT*/
    A1 [NOT] (SUBQUERY) /*IL PREDICATO É VERO QUANDO NON SODDISFANO LE CONDIZIONI DELLA SUBQUERY*/

    /*VANTAGGI DELLA FORMA NIDIFICATA:*/
        /*-MENO DICHIARATIVA, RICHIEDE MENO VARIABILI
          -LA FORMA PIANA E NIDIFICATA POSSONO ESSERE COMBINATE
          -LE SUBQUERY NON POSSONO CONTERENE OPERATORI INSIEMISTICI
        */

    /*REGOLE DI VISIBILITÁ:*/
        /*-NON É POSSIBILE FARE RIFERMENTI A VARIABILI PIÚ INTERNE
          -SE UN NOME DI VARIABILE É OMESSO SI FA RIFERIMENTO ALLA VARIABILE PIÚ 'VICINA'
          -IN UN BLOCCO INTERNO SI PUÓ FARE RIFERMENTO A VARIABILI ESTERNE
        */
    
    /*EXISTS: CONDIZIONI DI ESISTENZA CHE VERIFICANO PRIMA L'ESTERNA E POI L' INTERNA*/
    EXISTS (SUBQUERY)
    /*EX*/SELECT * FROM Persone WHERE EXISTS ( SELECT *  FROM Paternita WHERE Padre = Nome) OR 
          EXISTS ( SELECT * FROM Maternita WHERE Madre = Nome)

    /*VEDERE LEZIONE 9*/

    /*CREAZIONE DATABASE*/
    CREATE SCHEMA (NOME) AUTHORIZATION (UTENTE)

    /*CANCELLAZIONE DATABASE*/
    DROP SCHEMA (NOME) [RESTRICT|CASCADE]
    /*RESTRICT: LA CANCELLAZIONE NON VIENE ESEGUITA SE IL DATABASE NON É VUOTO*/
    /*CASCADE: CANCELLA TUTTO IL DATABASE COMPRESO DI DATI*/

    /*CREAZIONE DI UNA TABELLA: DEFINISCE UNO SCHEMA DI RELAZIONI (VUOTO O NON), DEFINDENDO ATTRIBUTI, RELAZIONI E VINCOLI*/
    CREATE TABLE TABELLA(
      A1 TIPO [VINCOLO,{VINCOLO}],
      A2 TIPO [VINCOLO, {VINCOLO}]
    )

    /*DOMINIO/TIPI DI VARIABILIO*/
    /*DOMINI ELEMENTARI (PREDEFINITI): CHAR, INT, VARCHAR*/
    /*DOMINI DEFINITI DALL'UTENTE*/

    /*EX*/ VARCHAR(n) /*STRINGHE DI LUNGHEZZA n CON AL MASSIMO n CARATTERI*/
           CHAR(n) /*STRINGHE DI LUNGHEZZA n*/
           INTEGER /*INT*/
           REAL /*REALI*/
           NUMERIC(p,s) /*p CIFRE DI CUI s DECIMALI*/
           FLOAT(p)
           DATE, TIME /*DATA E ORA*/

    /*CREAZIONE DI UN TIPO: DEFINIRE UN TIPO (SEMPLICE) PERSONALIZZATO*/
    CREATE DOMAIN (NOME) 
    /*EX*/CREATE DOMAIN Voto AS SMALLINT DEFAULT NULL CHECK ( value >=18 AND value <= 30 )

    /*VINCOLI D'INTEGRITÁ*/
    /*VINCOLO INTRARELAZIONALE: NELL'AMBITO DELLA STESSA RELAZIONE*/
    /*VINCOLO REFERENZIALE: TRA DIVERSE RELAZIONI*/

    /*CONTROLLO DEI VINCOLI D'INTEGRITÁ:*/
    /*-DURANTE LA INSERT, DELETE E UPDATE*/
    /*-DEVONO ESSERE SEMPRE SODDISFATTI PER CONCLUDERE LA TRANSAZIONE*/
    /*-L'UTENTE PUÓ OPZIONALMENTE DEFINIRE DELLE AZIONI PER RIPRISTINARE L'IDENTITÁ*/

    /*A CHE SERVONO:*/
    /*-MEGLIORARE LA QUALITÁ DEI DATI*/
    /*-ARRICCHIRE SEMANTICAMENTE IL DATABASE*/
    /*-LA LORO DEFINIZIONE É PARTE DELLA PROGETTAZIONE DEL DATABASE*/
    /*-USATI INTERNAMENTE DAL SISTEMA PER OTTIMIZZARE L'ESECUZIONE*/

    /*ELENCO DI VINCOLI*/
    NOT NULL
    UNIQUE /*DERFINISCE CHIAVI*/
    PRIMARY KEY /*CHIAVE PRIMARIA, UNA SOLA, IMPLICA NOT NULL*/
    CHECK

    /*UNIQUE E PRIMARY KEY*/
    /*DUE FORME:*/
      /*-NELLA DEFINIZIONE DI UN ATTRIBUTO*/
      /*-COME ELEMENTO SEPARATO*/

    /*VINCOLI INTERELAZIONALI*/
    /*REFERENCES E FOREIGN KEY: PERMETTONO DI DEFINIRE VINCOLI DI INTEGRITÁ REFERENZIALI*/
    /*DUE FORME:*/
      /*-SINGOLI ATTRIBUTI*/
      /*-PIÚ ATTRIBUTI*/

    /*CHECK*/

    /*VINCOLI SU UN RECORD*/
    NOT NULL /*É IMPLICATO SE L'ATTRIBUTO FA PARTE DI UNA CHIAVE PRIMARIA*/ù
    CHECK (CONDIZIONE) /*SPECIFICA I VALORI AMMISSIBILI, ANCHE PER VALORI DIVERSI DELLA STESSA n-UPLA.*/ 
    /*EX*/ Voto INTEGER NOT NULL CHECK (18 >= Voto AND Voto <=31)
    DEFAULT (COSTANTE|NULL) /*ASSEGNA QUEL VALORE DI DEFAULT AD OGNI INSERIMENTO*/

    /*MODIFICA DEGLI SCHEMI*/
    AFTER TABLE
    AFTER DOMAIN
    DROP DOMAIN
    DROP TABLE

    /*VISTE/VIEW: TABELLE AUSILIARIE VIRTUALI, SONO VIRTUALI PROPRIO PERCHÉ NON SONO TABELLE MA RELAZIONI*/
    /*UTILIZZO:*/
      /*-SEMPLIFICAZIONE*/
      /*-PROIEZIONE DATI*/
      /*-SCOMPOSIZIONE QUERY COMPLESSE*/
      /*-RIORGANIZZARE SCHEMI SECONDO NUOVI SCHEMI*/

      








    